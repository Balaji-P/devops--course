<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Running Fault Tolerant Jenkins Inside A Docker Swarm Cluster | vfarcic.github.io</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Running Fault Tolerant Jenkins Inside A Docker Swarm Cluster" />
<meta property="og:locale" content="en_US" />
<link rel="canonical" href="http://localhost:4000/docker-swarm/docker-swarm-jenkins.html" />
<meta property="og:url" content="http://localhost:4000/docker-swarm/docker-swarm-jenkins.html" />
<meta property="og:site_name" content="vfarcic.github.io" />
<script type="application/ld+json">
{"url":"http://localhost:4000/docker-swarm/docker-swarm-jenkins.html","@type":"WebPage","headline":"Running Fault Tolerant Jenkins Inside A Docker Swarm Cluster","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="stylesheet" href="/assets/css/style.css?v=d7b0fccce7a840960ab2c608e690e524c171b2d9">
  </head>
  <body>
    <div class="container-lg px-3 my-5 markdown-body">
      
      <h1><a href="http://localhost:4000/">vfarcic.github.io</a></h1>
      

      <h1 id="running-fault-tolerant-jenkins-inside-a-docker-swarm-cluster">Running Fault Tolerant Jenkins Inside A Docker Swarm Cluster</h1>

<p>The text that follows contains excerpts from the <em>Automating Continuous Deployment Flow With Jenkins</em> chapter of the <a href="https://leanpub.com/the-devops-2-1-toolkit">The DevOps 2.1 Toolkit: Docker Swarm</a> book. In this article, we’ll discuss a way to create a Jenkins service inside a Docker Swarm cluster and some of the benefits such a service provides.</p>

<h2 id="environment-setup">Environment Setup</h2>

<p>We’ll start by creating a Docker Swarm cluster. I will assume you already have at least a basic knowledge how Docker Swarm Mode works. If you don’t, I suggest you read the <a href="https://technologyconversations.com/2016/07/29/docker-swarm-introduction-tour-around-docker-1-12-series/">Docker Swarm Introduction (Tour Around Docker 1.12 Series)</a> article or fetch <a href="https://leanpub.com/the-devops-2-1-toolkit">The DevOps 2.1 Toolkit: Docker Swarm</a> book.</p>

<p>T&gt; Some of the files will be shared between the host file system and Docker Machines we’ll create soon. Docker Machine makes the whole directory that belongs to the current user available inside the VM. Therefore, please make sure that the code is cloned inside one of the user’s sub-folders.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/vfarcic/cloud-provisioning.git

<span class="nb">cd </span>cloud-provisioning

scripts/dm-swarm-2.sh
</code></pre></div></div>

<p>We cloned the <code class="highlighter-rouge">cloud-provisioning</code> repository and executed the <a href="https://github.com/vfarcic/cloud-provisioning/blob/master/scripts/dm-swarm-2.sh">scripts/dm-swarm.sh</a> script that created the production cluster.</p>

<p>Let’s confirm that the cluster was indeed created correctly.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">eval</span> <span class="k">$(</span>docker-machine env swarm-1<span class="k">)</span>

docker node <span class="nb">ls</span>
</code></pre></div></div>

<p>The output of the <code class="highlighter-rouge">node ls</code> command is as follows (IDs are removed for brevity).</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HOSTNAME  STATUS  AVAILABILITY  MANAGER STATUS
swarm-2   Ready   Active        Reachable
swarm-1   Ready   Active        Leader
swarm-3   Ready   Active        Reachable
</code></pre></div></div>

<p>Now that the production cluster is up and running, we can create Jenkins service.</p>

<h2 id="jenkins-service">Jenkins Service</h2>

<p>Traditionally, we would run Jenkins in its own server. Even if we’d choose to share server’s resources with other applications, the deployment would still be static. We’d run a Jenkins instance (without or without Docker) and hope that it never fails. The problem with this approach is in the fact that every application fails sooner or later. Either the process will stop, or the whole node will die. Either way, Jenkins, like any other application, will stop working at some moment.</p>

<p>The problem is that Jenkins become a critical application in many organizations. If we move the execution or, to be more precise, triggering of all automation into Jenkins, we create a strong dependency. If Jenkins is not running, our code is not built, it is not tested, and it is not deployed. Sure, when it fails, you can bring it up again. If the server it is running on stops working, you can deploy it somewhere else. The downtime, assuming that happens during working hours, will not be long. An hour, maybe two, or even more time will pass since the moment it stops working, someone finds out, notifies someone else, that someone restarts the application or provisions a new server. Is that a long time? It depends on the size of your organization. The more people depend on something, the bigger the cost when that something doesn’t work. Even if such a downtime and the cost it produces is not critical, we already have all the knowledge and the tools to avoid it. All we have to do is create another service and let Swarm take care of the rest.</p>

<p>Let’s create a Jenkins service.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mkdir <span class="nt">-p</span> docker/jenkins

docker service create <span class="nt">--name</span> jenkins <span class="se">\</span>
    <span class="nt">-p</span> 8082:8080 <span class="se">\</span>
    <span class="nt">-p</span> 50000:50000 <span class="se">\</span>
    <span class="nt">-e</span> <span class="nv">JENKINS_OPTS</span><span class="o">=</span><span class="s2">"--prefix=/jenkins"</span> <span class="se">\</span>
    <span class="nt">--mount</span> <span class="s2">"type=bind,source=</span><span class="nv">$PWD</span><span class="s2">/docker/jenkins,target=/var/jenkins_home"</span> <span class="se">\</span>
    <span class="nt">--reserve-memory</span> 300m <span class="se">\</span>
    jenkins:2.7.4-alpine

docker service ps jenkins
</code></pre></div></div>

<p>Jenkins stores its state in the file system. Therefore, we started by creating a directory (<code class="highlighter-rouge">mkdir</code>) on the host. It will be used as Jenkins home. Since we are inside one of the subdirectories of our host’s user, the <code class="highlighter-rouge">docker/jenkins</code> directory is mounted on all the machines we created.</p>

<p>Next, we created the service. It exposes the internal port <code class="highlighter-rouge">8080</code> as <code class="highlighter-rouge">8082</code> as well as the port <code class="highlighter-rouge">50000</code>. The first one is used to access Jenkins’ UI and the second for master/agent communication. We also defined the URL prefix as <code class="highlighter-rouge">/jenkins</code> and mounted the Jenkins home directory. Finally, we reserved <code class="highlighter-rouge">300m</code> of memory.</p>

<p>Once the image is downloaded, the output of the <code class="highlighter-rouge">service ps</code> command is as follows (IDs are removed for brevity).</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NAME      IMAGE                NODE    DESIRED STATE CURRENT STATE          ERROR
jenkins.1 jenkins:2.7.4-alpine swarm-1 Running       Running 52 seconds ago
</code></pre></div></div>

<p><img src="images/ch06/cd-environment-jenkins-only.png" alt="Figure 6-1: Production cluster with the Jenkins service" /></p>

<p>Jenkins 2 changed the setup process. While the previous versions allowed us to run it without any mandatory configuration, the new Jenkins forces us to go through some steps manually. Unfortunately, at the time of this writing, there is no good API to help us automate the process. While there are some “tricks” we could use, the benefits are not high enough when compared with the additional complexity they introduce. After all, we’ll setup Jenkins only once, so there is no big incentive to automate the process (at least until configuration API is created).</p>

<p>Let’s open the UI.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>open http://<span class="k">$(</span>docker-machine ip swarm-1<span class="k">)</span>:8082/jenkins
</code></pre></div></div>

<p>The first thing you will notice is that you are required to introduce the <em>Administrator password</em>. Quite a few enterprise users requested security hardening. As a result, Jenkins cannot be accessed, anymore, without initializing a session. If you are new to Jenkins, or, at least, version 2, you might wonder what the password is. It is output to logs (in our case <code class="highlighter-rouge">stdout</code>) as well as to the <code class="highlighter-rouge">secrets/initialAdminPassword</code> file which will be removed at the end of the setup process.</p>

<p>Let’s see the content of the <code class="highlighter-rouge">secrets/initialAdminPassword</code> file.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat </span>docker/jenkins/secrets/initialAdminPassword
</code></pre></div></div>

<p>The output will be a long string that represents the temporary password. Please copy it, go back to the UI, paste it to the <em>Administrator password</em> field, and click the <em>Continue button</em>.</p>

<p><img src="images/ch06/jenkins-setup-password.png" alt="Figure 6-2: Unlock Jenkins screen" /></p>

<p>Once you unlock Jenkins, you will be presented with a choice to <em>Install suggested plugins</em> or select those that fit your needs. The recommended plugins fit most commonly used scenarios so we’ll go with that option.</p>

<p>Please click the <em>Install suggested plugins</em> button.</p>

<p>Once the plugins are downloaded and installed, we are presented with a screen that allows us to create the first admin user. Please use <em>admin</em> as both the <em>username</em> and the <em>password</em>. Fill free to fill the rest of the fields with any value. Once you’re done, click the <em>Save and Finish</em> button.</p>

<p><img src="images/ch06/jenkins-setup-admin-user.png" alt="Figure 6-3: Create First Admin User screen" /></p>

<p>Jenkins is ready. All that’s left, for now, is to click the <em>Start using Jenkins</em> button.</p>

<p>Now we can test whether Jenkins failover works.</p>

<h2 id="jenkins-failover">Jenkins Failover</h2>

<p>Let’s stop the service and observe Swarm in action. To do that, we need to find out the node it is running in, point our Docker client to it, and remove the container.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">NODE</span><span class="o">=</span><span class="k">$(</span>docker service ps <span class="nt">-f</span> desired-state<span class="o">=</span>running jenkins | tail +2 | awk <span class="s1">'{print $4}'</span><span class="k">)</span>

<span class="nb">eval</span> <span class="k">$(</span>docker-machine env <span class="nv">$NODE</span><span class="k">)</span>

docker rm <span class="nt">-f</span> <span class="k">$(</span>docker ps <span class="nt">-qa</span> <span class="nt">-f</span> <span class="s2">"ancestor=jenkins:2.7.4-alpine"</span><span class="k">)</span>
</code></pre></div></div>

<p>We listed Jenkins processes and applied the filter that will return only the one with the desired state <code class="highlighter-rouge">running</code> (<code class="highlighter-rouge">docker service ps -f desired-state=running jenkins</code>). The output was piped to the tail command that removed the header (<code class="highlighter-rouge">tail +2</code>) and, later on, piped again to the <code class="highlighter-rouge">awk</code> command that limited the output to the fourth column (<code class="highlighter-rouge">awk '{print $4}'</code>) that contains the node the process is running in. The final result was stored in the <code class="highlighter-rouge">NODE</code> variable.</p>

<p>Later on, we used the <code class="highlighter-rouge">eval</code> command to create environment variables that will be used by our Docker client to operate the remote engine. Finally, we removed the container with the combination of the <code class="highlighter-rouge">ps</code> and <code class="highlighter-rouge">rm</code> commands.</p>

<p>As we already learned in the previous chapters, if a container fails, Swarm will run it again somewhere inside the cluster. When we created the service, we told swarm that the desired state is to have one instance running and Swarm is doing its best to make sure our expectations are fulfilled.</p>

<p>Let us confirm that the service is, indeed, running.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker service ps jenkins
</code></pre></div></div>

<p>If Swarm decided to re-run Jenkins on a different node, it might take a few moments until the image is pulled. After a while, the output of the <code class="highlighter-rouge">service ps</code> command should be as follows.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NAME           IMAGE           NODE     DESIRED STATE  CURRENT STATE                   ERROR
jenkins.1      jenkins:alpine  swarm-3  Running        Running less than a second ago
 \_ jenkins.1  jenkins:alpine  swarm-1  Shutdown       Failed 5 seconds ago            "task: non-zero exit (137)"
</code></pre></div></div>

<p>We can do a final confirmation by reopening the the UI.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>open http://<span class="k">$(</span>docker-machine ip swarm-1<span class="k">)</span>:8082/jenkins
</code></pre></div></div>

<p>Since Jenkins does not allow unauthenticated users, you’ll have to login. Please use <em>admin</em> as both the <em>User</em> and the <em>Password</em>.</p>

<p>You’ll notice that, this time, we did not have to repeat the setup process. Even though a fresh new Jenkins image is run on a different node, the state is still preserved thanks to the host directory we mounted.</p>

<p>We managed to make Jenkins fault tolerant, but we did not manage to make it run without any downtime. Due to its architecture, Jenkins master cannot be scaled. As a result, when we simulated a failure by removing the container, there was no second instance to absorb the traffic. Even though Swarm re-scheduled it on a different node, there was some downtime. During a short period, the service was not accessible. While that is not a perfect situation, we managed to reduce downtime to a minimum. We made it fault tolerant, but could not make it run without downtime. Considering its architecture, we did the best we could.</p>

<h2 id="the-devops-21-toolkit-docker-swarm">The DevOps 2.1 Toolkit: Docker Swarm</h2>

<p><a href="https://leanpub.com/the-devops-2-1-toolkit"><img src="https://technologyconversations.files.wordpress.com/2016/09/cover-ebook-small.png?w=287" alt="The DevOps 2.1 Toolkit: Docker Swarm" width="287" height="300" class="alignright size-medium wp-image-3383" /></a>If you liked this article, you might be interested in <strong><a href="https://leanpub.com/the-devops-2-1-toolkit">The DevOps 2.1 Toolkit: Docker Swarm</a></strong> book. Unlike the previous title in the series (<strong><a href="http://www.amazon.com/dp/B01BJ4V66M">The DevOps 2.0 Toolkit: Automating the Continuous Deployment Pipeline with Containerized Microservices</a></strong>) that provided a general overlook of some of the latest DevOps practices and tools, this book is <strong>dedicated entirely to Docker Swarm* and the processes and tools we might need to **build, test, deploy, and monitor services</strong> running inside a cluster.</p>

<p>The book is still under “development”. You can get a copy from <a href="https://leanpub.com/the-devops-2-1-toolkit">LeanPub</a>.  It is also available as <a href="https://leanpub.com/b/thedevopstoolkitseries">The DevOps Toolkit Series</a> bundle. If you download it now, before it is fully finished, you will get frequent updates with new chapters and corrections. More importantly, you will be able to influence the direction of the book by sending me your feedback.</p>

<p>I choose the lean approach to book publishing because I believe that early feedback is the best way to produce a great product. Please help me make this book a reference to anyone wanting to adopt Docker Swarm for cluster orchestration and scheduling.</p>


      
      <div class="footer border-top border-gray-light mt-5 pt-3 text-right text-gray">
        This site is open source. <a href="https://github.com/vfarcic/vfarcic.github.io/edit/gh-pages/docker-swarm/docker-swarm-jenkins.md">Improve this page</a>.
      </div>
      
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.1.0/anchor.min.js" integrity="sha256-lZaRhKri35AyJSypXXs4o6OPFTbTmUoltBbDCbdzegg=" crossorigin="anonymous"></script>
    <script>anchors.add();</script>
    
  </body>
</html>
