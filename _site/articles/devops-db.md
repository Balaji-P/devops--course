**Q:** Where do databases fit into DevOps?

DevOps is about extending the scope of what a single team is in charge of. With Agile we got teams that consist of analysts (now we call them product owners), developers, and testers (assuming there is such a thing as a dedicated tester). Now, with the wider adoption of DevOps principles, the skills present in a team are extended to operators, sysadmins, database administrators, and all other experts that were sitting somewhere in a basement wondering why they are not invited to those agile parties. That means that a team is now in charge of everything. By everything I don't mean "feature is done, open a JIRA ticket and assign it to a sysadmin," but everything as in "the new feature is done when it's running in production and does not crash." Such a change in the way how we approach software development changes everything and that includes databases. We expect a feature to be in production almost instantly. The delay between a feature being developed and deployed to production is now measured in minutes, if not seconds. And we develop a new feature every week, every day, often even multiple times a day.

Such a change in the speed we're delivering software inevitably changes the way we operate databases. A push to Git will be deployed to production. That means that we need tests that validate that feature. That's one of the reasons we adopted TDD. However, tests are not the only requirement of what a commit should have. Database changes is another. If a feature requires database schema to be changed, it needs to be present in that commit. If data needs to be transformed, a script that does it needs to be there as well. And so on and so forth. Now, imagine how would that look like if a separate department still owns databases. "We have a new feature! It's ready for production. Let's open a JIRA ticket and wait our turn until DBAs get a bit of free time. See you next week." Such a practice, while still used in enterprises, is unacceptable if a company wants to compete in today's market. The more time it takes for a feature to reach production, the more money is lost by not monetizing on that feature. The later our users need to wait until a feature is in their hands, the later we get feedback required for the development of new features or improvement of those already delivered. Databases cannot be a bottleneck, so the database expertise needs to be inside the team that works on a service.

Another stumbling block, at least when databases are concerned, is the monolithic approach. The industry is moving towards microservices as a way to have a technological separation that matches team organization. Small and self-sufficient teams need to work on small and autonomous services. A team consists of ten people or less. Anything bigger than that is not a team but a school reunion. The only way for a team to be self-sufficient is to own everything related to a service they're developing. That includes a database. If it owns a service that uses a shared database, lean time is inevitable. That team will continually crash with others. There will be conflicts in schema changes (assuming there is a schema). A small change made by one team can have a disastrous effect on the other. For that reason, and quite a few others, we are moving towards smaller databases dedicated to one service. If some other service needs our data, the only way it can access it is through the API we developed. By coupling a service with a database we get loose coupling (between services) and high cohesion (within a service).

The change from one monolithic database to many smaller ones tied to a single service inevitably changes the processes around those databases. There is no central point where everything flows to. The systems are now truly distributed and with them the teams as well. There is no DBA department in charge of all your database needs but DBA skills injected into small independent teams.

All this does not mean that monolithic databases are the thing of the past nor those highly specialized DBA experts are not needed anymore. Quite the contrary. However, an important part of that work is now dissolved into other teams. There is a clear separation between DBA skills required to deliver a new feature and DBA skills needed to keep the whole system running. DB experts are experiencing the same transformation that is way underway with operators and sysadmins. The only difference is, in my opinion, that sysadmins started adopting DevOps practices earlier and DBAs still need to catch up.

**Q:** How often are databases being changed?

That depends on a database. If it's a big monolithic database that stores data of the whole system, the answer is preferably never (if DBA is asked). If a department is in charge of it and the main (sometimes even only) objective is to keep the system stable, the easiest way to accomplish that is by not introducing any change. If many different teams are working on many different services that all communicate with a single database, change is hard and perilous. As a result, changes are often postponed out of fear.

On the other hand, if databases are split in a way that each service owns a database, the frequency of change tends to be much higher. When there is an apparent owner, change is safer and performed more often. The problem is that ownership is often misunderstood. Owning a database does not mean that only John can access it nor that it belongs to a dedicated department. Instead, owning a database means that only one service can access it and that the scope of that service is clearly defined and preferably small. It is not uncommon, in a microservices world where each service owns a database, to have multiple changes a day resulting in multiple deployments to production.

**Q:** How does that fit into continuous delivery?

Continuous delivery means that we are continuously delivering software to production. That does not mean "I'm done, see you next week once you figure out what to do with the DB." Database changes need to be part of that commit and, therefore, all the knowledge required for that change needs to be inside the team that is developing the service. Everything needs to be automated if we are to apply CD principles. After a commit is made, humans are not required. The only thing needed is a single finger that will press the "deploy to production" button at the end of the process. If you get rid of that button, continuous delivery becomes continuous deployment. You are neither of the two if you add more buttons, or you allow humans to intervene during the process. That does not mean that everyone needs to practice CD. But, if you do, remember that you are not allowed to intervene after a commit (button-pushing finger excluded). The only exception is when the CD pipeline fails. When that happens, it's "all hands on deck until the problem is fixed."

As a result of such a high level of automation, DBAs need to acquire coding skills. Their processes have to be automated. Their validations as well. Practicing CD means that we (DBAs included) need to become proactive and do all our tasks in advance in the form of scripts. Everyone is a coder, not matter whether his (or her) specialization is in frontend, backend, operations, or databases.
