<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Using Docker Stack And Compose YAML Files To Deploy Swarm Services | vfarcic.github.io</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Using Docker Stack And Compose YAML Files To Deploy Swarm Services" />
<meta property="og:locale" content="en_US" />
<link rel="canonical" href="http://localhost:4000/articles/docker-stack.html" />
<meta property="og:url" content="http://localhost:4000/articles/docker-stack.html" />
<meta property="og:site_name" content="vfarcic.github.io" />
<script type="application/ld+json">
{"url":"http://localhost:4000/articles/docker-stack.html","@type":"WebPage","headline":"Using Docker Stack And Compose YAML Files To Deploy Swarm Services","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="stylesheet" href="/assets/css/style.css?v=d7b0fccce7a840960ab2c608e690e524c171b2d9">
  </head>
  <body>
    <div class="container-lg px-3 my-5 markdown-body">
      
      <h1><a href="http://localhost:4000/">vfarcic.github.io</a></h1>
      

      <h1 id="using-docker-stack-and-compose-yaml-files-to-deploy-swarm-services">Using Docker Stack And Compose YAML Files To Deploy Swarm Services</h1>

<p><strong>Bells are ringing! Docker v1.13 is out!</strong></p>

<p>The most common question I receive during my Docker-related talks and workshops is usually related to Swarm and Compose.</p>

<p><em>Someone</em>: How can I use Docker Compose with Docker Swarm?</p>

<p><em>Me</em>: You can’t! You can convert your Compose files into a Bundle that does not support all Swarm features. If you want to use Swarm to its fullest, be prepared for <code class="highlighter-rouge">docker service create</code> commands that contain a never ending list of arguments.</p>

<p>Such an answer was usually followed with disappointment. Docker Compose showed us the advantages of specifying everything in a YAML file as opposed to trying to remember all the arguments we have to pass to <code class="highlighter-rouge">docker</code> commands. It allowed us to store service definitions in a repository thus providing a reproducible and well-documented process for managing them. Docker Compose replaced bash scripts, and we loved it. Then, Docker v1.12 came along and put a difficult choice in front of us. Should we adopt Swarm and discard Compose? Since summer 2016, Swarm and Compose were not in love anymore. It was a painful divorce.</p>

<p>But, after almost half a year of separation, they are back together, and we can witness their second honeymoon. Kind of… We do not need Docker Compose binary for Swarm services, but we can use its YAML files.</p>

<p>Docker Engine v1.13 introduced support for Compose YAML files within the <code class="highlighter-rouge">stack</code> command. At the same time, Docker Compose v1.10 introduced a new version 3 of its format. Together, they allow us to manage our Swarm services using already familiar Docker Compose YAML format.</p>

<p>I will assume you are already familiar with Docker Compose and won’t go into details of everything we can do with it. Instead, we’ll go through an example of creating a few Swarm services.</p>

<p>We’ll explore how to create <a href="http://proxy.dockerflow.com/">Docker Flow Proxy</a> service through <em>Docker Compose</em> files and the <code class="highlighter-rouge">docker stack deploy</code> command.</p>

<h2 id="requirements">Requirements</h2>

<p>The examples that follow assume that you are using Docker v1.13+, Docker Compose v1.10+, and Docker Machine v0.9+.</p>

<blockquote>
  <p>If you are a Windows user, please run all the examples from <em>Git Bash</em> (installed through <em>Docker Toolbox</em>). Also, make sure that your Git client is configured to check out the code <em>AS-IS</em>. Otherwise, Windows might change carriage returns to the Windows format.</p>
</blockquote>

<h2 id="swarm-cluster-setup">Swarm Cluster Setup</h2>

<p>To setup an example Swarm cluster using Docker Machine, please run the commands that follow.</p>

<blockquote>
  <p>Feel free to skip this section if you already have a working Swarm cluster.</p>
</blockquote>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl <span class="nt">-o</span> swarm-cluster.sh <span class="se">\</span>
    https://raw.githubusercontent.com/<span class="se">\</span>
docker-flow/docker-flow-proxy/master/scripts/swarm-cluster.sh

chmod +x swarm-cluster.sh

./swarm-cluster.sh

docker-machine ssh node-1
</code></pre></div></div>

<p>Now we’re ready to deploy the <code class="highlighter-rouge">docker-flow-proxy</code> service.</p>

<h2 id="creating-swarm-services-through-docker-stack-commands">Creating Swarm Services Through Docker Stack Commands</h2>

<p>We’ll start by creating a network.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker network create <span class="nt">--driver</span> overlay proxy
</code></pre></div></div>

<p>The <em>proxy</em> network will be dedicated to the proxy container and services that will be attached to it.</p>

<p>We’ll use <a href="https://github.com/docker-flow/docker-flow-proxy/blob/master/docker-compose-stack.yml">docker-compose-stack.yml</a> from the <a href="https://github.com/docker-flow/docker-flow-proxy">docker-flow/docker-flow-proxy</a> repository to create <code class="highlighter-rouge">docker-flow-proxy</code> and <code class="highlighter-rouge">docker-flow-swarm-listener</code> services.</p>

<p>The content of the <code class="highlighter-rouge">docker-compose-stack.yml</code> file is as follows.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>version: "3"

services:

  proxy:
    image: dockerflow/docker-flow-proxy
    ports:
      - 80:80
      - 443:443
    networks:
      - proxy
    environment:
      - LISTENER_ADDRESS=swarm-listener
      - MODE=swarm
    deploy:
      replicas: 2

  swarm-listener:
    image: vfarcic/docker-flow-swarm-listener
    networks:
      - proxy
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
    environment:
      - DF_NOTIFY_CREATE_SERVICE_URL=http://proxy:8080/v1/docker-flow-proxy/reconfigure
      - DF_NOTIFY_REMOVE_SERVICE_URL=http://proxy:8080/v1/docker-flow-proxy/remove
    deploy:
      placement:
        constraints: [node.role == manager]

networks:
  proxy:
    external: true
</code></pre></div></div>

<p>The format is written in version <code class="highlighter-rouge">3</code> (mandatory for <code class="highlighter-rouge">docker stack deploy</code>).</p>

<p>It contains two services; <code class="highlighter-rouge">proxy</code> and <code class="highlighter-rouge">swarm-listener</code>. Since this article is not meant to teach you how to use the proxy, I won’t go into the meaning of each argument.</p>

<p>When compared with previous Compose versions, most of the new arguments are defined within <code class="highlighter-rouge">deploy</code>. You can think of that section as a placeholder for Swarm-specific arguments. In this case, we are specifying that the <code class="highlighter-rouge">proxy</code> service should have two replicas while the <code class="highlighter-rouge">swarm-listener</code> service should be constrained to manager roles. Everything else defined for those two services is using the same format as in earlier Compose versions.</p>

<p>At the bottom of the YAML file is the list of networks which are referenced within <code class="highlighter-rouge">services</code>. If a service does not specify any, the <code class="highlighter-rouge">default</code> network will be created automatically. In this case, we opted for manual creation of a network since services from other stacks should be able to communicate with the proxy. Therefore, we created a network manually and defined it as <code class="highlighter-rouge">external</code> in the YAML file.</p>

<p>Let’s create the stack based on the YAML file we explored.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl <span class="nt">-o</span> docker-compose-stack.yml <span class="se">\</span>
    https://raw.githubusercontent.com/<span class="se">\</span>
docker-flow/docker-flow-proxy/master/docker-compose-stack.yml

docker stack deploy <span class="nt">-c</span> docker-compose-stack.yml proxy
</code></pre></div></div>

<p>The first command downloaded the Compose file <a href="https://github.com/docker-flow/docker-flow-proxy/blob/master/docker-compose-stack.yml">docker-compose-stack.yml</a> from the <a href="https://github.com/docker-flow/docker-flow-proxy">docker-flow/docker-flow-proxy</a> repository. The second command created the services that form the stack.</p>

<p>The tasks of the stack can be seen through the <code class="highlighter-rouge">stack ps</code> command.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker stack ps proxy
</code></pre></div></div>

<p>The output is as follows (IDs are removed for brevity).</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NAME                   IMAGE                                     NODE   DESIRED STATE CURRENT STATE         ERROR  PORTS
proxy_proxy.1          dockerflow/docker-flow-proxy:latest       node-2 Running       Running 2 minutes ago
proxy_swarm-listener.1 vfarcic/docker-flow-swarm-listener:latest node-1 Running       Running 2 minutes ago
proxy_proxy.2          dockerflow/docker-flow-proxy:latest       node-3 Running       Running 2 minutes ago
</code></pre></div></div>

<p>We are running two replicas of the <code class="highlighter-rouge">proxy</code> (for high-availability in the case of a failure) and one of the <code class="highlighter-rouge">swarm-listener</code>.</p>

<h2 id="deploying-more-stacks">Deploying More Stacks</h2>

<p>Let’s deploy another stack.</p>

<p>This time we’ll use Docker stack defined in the Compose file <a href="https://github.com/vfarcic/go-demo/blob/master/docker-compose-stack.yml">docker-compose-stack.yml</a> located in the <a href="https://github.com/vfarcic/go-demo/">vfarcic/go-demo</a> repository. It is as follows.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>version: '3'

services:

  main:
    image: vfarcic/go-demo
    environment:
      - DB=db
    networks:
      - proxy
      - default
    deploy:
      replicas: 3
      labels:
        - com.df.notify=true
        - com.df.distribute=true
        - com.df.servicePath=/demo
        - com.df.port=8080

  db:
    image: mongo
    networks:
      - default

networks:
  default:
    external: false
  proxy:
    external: true
</code></pre></div></div>

<p>The stack defines two services (<code class="highlighter-rouge">main</code> and <code class="highlighter-rouge">db</code>). They will communicate with each other through the <code class="highlighter-rouge">default</code> network that will be created automatically by the stack (no need for <code class="highlighter-rouge">docker network create</code> command). Since the <code class="highlighter-rouge">main</code> service is an API, it should be accessible through the proxy, so we’re attaching <code class="highlighter-rouge">proxy</code> network as well.</p>

<p>The important thing to note is that we used the <code class="highlighter-rouge">deploy</code> section to define Swarm-specific arguments. In this case, the <code class="highlighter-rouge">main</code> service defines that there should be three replicas and a few labels. As with the previous stack, we won’t go into details of each service. If you’d like to go into more depth of the labels used with the <code class="highlighter-rouge">main</code> service, please visit the <a href="http://proxy.dockerflow.com/swarm-mode-auto/">Running Docker Flow Proxy In Swarm Mode With Automatic Reconfiguration</a> tutorial.</p>

<p>Let’s deploy the stack.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl <span class="nt">-o</span> docker-compose-go-demo.yml <span class="se">\</span>
    https://raw.githubusercontent.com/<span class="se">\</span>
vfarcic/go-demo/master/docker-compose-stack.yml

docker stack deploy <span class="se">\</span>
    <span class="nt">-c</span> docker-compose-go-demo.yml go-demo

docker stack ps go-demo
</code></pre></div></div>

<p>We downloaded the stack definition, executed <code class="highlighter-rouge">stack deploy</code> command that created the services and run the <code class="highlighter-rouge">stack ps</code> command that lists the tasks that belong to the <code class="highlighter-rouge">go-demo</code> stack. The output is as follows (IDs are removed for brevity).</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NAME           IMAGE                  NODE    DESIRED STATE CURRENT STATE          ERROR PORTS
go-demo_main.1 vfarcic/go-demo:latest node-2 Running        Running 7 seconds ago
...
go-demo_db.1   mongo:latest           node-2 Running        Running 21 seconds ago
go-demo_main.2 vfarcic/go-demo:latest node-2 Running        Running 19 seconds ago
...
go-demo_main.3 vfarcic/go-demo:latest node-2 Running        Running 20 seconds ago
...
</code></pre></div></div>

<p>Since Mongo database is much bigger than the <code class="highlighter-rouge">main</code> service, it takes more time to pull it, resulting in a few failures. The <code class="highlighter-rouge">go-demo</code> service is designed to fail if it cannot connect to its database. Once the <code class="highlighter-rouge">db</code> service is running, the <code class="highlighter-rouge">main</code> service should stop failing, and we’ll see three replicas with the current state <code class="highlighter-rouge">Running</code>.</p>

<p>After a few moments, the <code class="highlighter-rouge">swarm-listener</code> service will detect the <code class="highlighter-rouge">main</code> service from the <code class="highlighter-rouge">go-demo</code> stack and send the <code class="highlighter-rouge">proxy</code> a request to reconfigure itself. We can see the result by sending an HTTP request to the proxy.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl <span class="nt">-i</span> <span class="s2">"localhost/demo/hello"</span>
</code></pre></div></div>

<p>The output is as follows.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HTTP/1.1 200 OK
Date: Thu, 19 Jan 2017 23:57:05 GMT
Content-Length: 14
Content-Type: text/plain; charset=utf-8

hello, world!
</code></pre></div></div>

<p>The proxy was reconfigured and forwards all requests with the base path <code class="highlighter-rouge">/demo</code> to the <code class="highlighter-rouge">main</code> service from the <code class="highlighter-rouge">go-demo</code> stack.</p>

<p>For more advanced usage of the proxy, please see the examples from <a href="http://proxy.dockerflow.com/swarm-mode-auto/">Running Docker Flow Proxy In Swarm Mode With Automatic Reconfiguration</a> tutorial or consult the <a href="http://proxy.dockerflow.com/config/">configuration</a> and <a href="http://proxy.dockerflow.com/usage/">usage</a> documentation.</p>

<h2 id="to-stack-or-not-to-stack">To Stack Or Not To Stack</h2>

<p>Docker stack is a great addition to the Swarm Mode. We do not have to deal with <code class="highlighter-rouge">docker service create</code> commands that tend to have a never ending list of arguments. With services specified in Compose YAML files, we can replace those long commands with a simple <code class="highlighter-rouge">docker stack deploy</code>. If those YAML files are stored in code repositories, we can apply the same practices to service deployments as to any other area of software engineering. We can track changes, do code reviews, share with others, and so on.</p>

<p>The addition of the Docker <code class="highlighter-rouge">stack</code> command and its ability to use Compose files is a very welcome addition to the Docker ecosystem.</p>

<h2 id="cleanup">Cleanup</h2>

<p>Please remove Docker Machine VMs we created. You might need those resources for some other tasks.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">exit

</span>docker-machine rm <span class="nt">-f</span> node-1 node-2 node-3
</code></pre></div></div>

<h1 id="the-devops-21-toolkit-docker-swarm">The DevOps 2.1 Toolkit: Docker Swarm</h1>

<p><a href="https://www.amazon.com/dp/1542468914"><img src="https://technologyconversations.files.wordpress.com/2016/09/cover-ebook-small.png?w=287" alt="The DevOps 2.1 Toolkit: Docker Swarm" width="287" height="300" class="alignright size-medium wp-image-3383" /></a>If you liked this article, you might be interested in <strong><a href="https://www.amazon.com/dp/1542468914">The DevOps 2.1 Toolkit: Docker Swarm</a></strong> book. Unlike the previous title in the series (<strong><a href="http://www.amazon.com/dp/B01BJ4V66M">The DevOps 2.0 Toolkit: Automating the Continuous Deployment Pipeline with Containerized Microservices</a></strong>) that provided a general overlook of some of the latest DevOps practices and tools, this book is <strong>dedicated entirely to Docker Swarm</strong> and the processes and tools we might need to <strong>build, test, deploy, and monitor services</strong> running inside a cluster.</p>

<p>You can get a copy from <a href="https://www.amazon.com/dp/1542468914">Amazon.com</a> (and the other worldwide sites) or <a href="https://leanpub.com/the-devops-2-1-toolkit">LeanPub</a>.  It is also available as <a href="https://leanpub.com/b/thedevopstoolkitseries">The DevOps Toolkit Series</a> bundle.</p>

<p>Give the book a try and let me know what you think.</p>


      
      <div class="footer border-top border-gray-light mt-5 pt-3 text-right text-gray">
        This site is open source. <a href="https://github.com/vfarcic/vfarcic.github.io/edit/gh-pages/articles/docker-stack.md">Improve this page</a>.
      </div>
      
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.1.0/anchor.min.js" integrity="sha256-lZaRhKri35AyJSypXXs4o6OPFTbTmUoltBbDCbdzegg=" crossorigin="anonymous"></script>
    <script>anchors.add();</script>
    
  </body>
</html>
